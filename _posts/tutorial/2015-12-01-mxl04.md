---
layout: post
title:  Sequence Functions
description: "An overview over the most important kind of functions in MxL: Sequence functions."
date:   2015-12-01 23:00:00
category: "tutorial"
tutorial: "MxL"
nr: 4
---

## Higher-Order Functions

Higher-order functions are functions, which can take functions as parameters. E.g. a function applyFunc of type Function<Function<Date, Number>, Date> is a higher-order function expecting a function and a date as parameter. The following table lists some exemplary and valid applications of this function, whereas each of them yields to the same result:

| Exemplary Expression                                                        | Description                       |
| --------------------------------------------------------------------------- | -------------------------------- |
| `let getDay =`<br/>`  (d:Date) => d.day in`<br/>`applyFunc(getDay, Today)`  | If there is a defined function, you might pass the function by its identifier. |
| `applyFunc((d:Date) => d.day, Today)`                                       | You can pass the function also as (typed) lambda expression. |
| `applyFunc(d =>d.day, Today)`                                               | In most cases, the type of the lambda expression can be inferred by MxL (e.g., by knowing the parameter type of the *applyFunc*). Hence, in this case, you can omit the parameter types of the lambda expression. |
| `applyFunc(day, Today)`                                                     | You can even further shorten the expression by using an implicit lambda as parameter. Since the *applyFunc* function knows the type of its first parameter, but discovers that day is neiter a function nor a known identifier, it will try to interpret the parameter expression as the method stub of a lambda and the unknown identifier as member of an implicit parameter: `<implicit param> => <implicit param>.day`. If this yields to the expected parameter type, the application of *applyFunc* is valid. |

### Also note

- A function returing a boolean value is called predicate, e.g. `Function<Object, Boolean>` or `Function<Number,Number,Boolean>`.
- A function which simply returns its only parameter is called the *Identity function*.

## Standard Sequence Functions

An integral purpose of MxLis querying an underlying data model. Hence, based on the sequence of objects of an arbitrary type, MxL has to be able to apply certain filters, projections, aggregations, etc. onto this sequence. In the following, MxL's standard sequence functions, which are inspired by Microsoft's [Standard Query Operators](https://msdn.microsoft.com/en-us/library/bb397896.aspx).

### Query functions

| Name          | Parameters                                                        | Returns       | Description                                                                                                                                                                                                                                     |
| ------------- | ----------------------------------------------------------------- | ------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `select`      | `map: Function<T,U>`                                              | `Sequence<U>` | Applies the *map*-function to each element of the source sequence and returns a sequence containing the results of each individual application.                                                                                                 |
| `selectMany`  | `map: Function<T,Sequence<U>>`                                    | `Sequence<U>` | Similar to the *select*-function, however, in *selectMany*, the *map*-function returns a sequence for each element. The concatenation of all sequences forms the result of the *selectMany*-function.                                           |
| `where`       | `pred: Function<T,Boolean>                                        | `Sequence<T>` | Filters the source list by the given predicate, i.e. all elements fulfilling the predicate remain in the sequence.                                                                                                                              |
| `groupby`     | `keySel: Function<T,K>`<br/>`groupMap: Function<Sequence<T>,V>?`  | `Map<K,V>`    | Groups the elements of the source list by the *keySel*-Function and applies the (optional) *groupMap*-function (if not provided, it is the identity function) on the elements of each single group.                                             |
| `orderby`     | `keySel: Function<T,Object>`<br/>`descending: Boolean?`           | `Sequence<T>` | Sorts the source sequence by the (optional) *keySel*, whereas a natural order will be applied. The (optional) *descending* parameter determines, if the elements should be ordered ascending ("lowest first") or descending ("highest first").  |

